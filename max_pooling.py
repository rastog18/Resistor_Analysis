# -*- coding: utf-8 -*-
"""max_pooling.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1lEXytXM9tMF4d0wbBJORCnYryPf-Y0VB
"""

## Max Pooling
# Updated 2/27/2024 - Joseph Huang
# Created 2/26/2024 - Joseph Huang

from google.colab import drive
drive.mount('/content/drive')

# Commented out IPython magic to ensure Python compatibility.
# %cd drive/MyDrive/VIP-SD(Spring2024)

import numpy as np
from PIL import Image
import matplotlib.pyplot as plt

IMG_PATH = 'test_images/IMG_2170.jpg'
image = plt.imread(IMG_PATH)
plt.imshow(image)

with Image.open(IMG_PATH) as img:
  width, height = img.size
  new_width = 250
  new_height = 100
  image = np.array(img.resize((new_width, new_height)))

row = len(image)
col = len(image[1])

# Create zero filled arrays for red, green, blue, and gray
red = np.zeros((row, col), np.dtype(np.uint8))
green = np.zeros((row, col), np.dtype(np.uint8))
blue = np.zeros((row, col), np.dtype(np.uint8))
gray = np.zeros((row, col), np.dtype(np.uint8))

# Load values into red, green, blue arrays
for i in range(row):
    for j in range(col):
        red[i][j] = image[i][j][0]
        green[i][j] = image[i][j][1]
        blue[i][j] = image[i][j][2]

# BT 709 Grayscale Equation
gray = (0.183 * red) + (0.614 * green) + (0.062 * blue)

plt.imshow(gray, cmap='gray')

import numpy as np

class MaxPooling2D:
    def __init__(self):
      None

    def forward(self, image):
        self.image = image
        height, width = image.shape
        new_height = height // 2
        new_width = width // 2

        pooled_image = np.zeros((new_height, new_width))

        for i in range(0, height, 2):
            for j in range(0, width, 2):
                patch = image[i:i+2, j:j+2]
                pooled_image[i//2, j//2] = np.max(patch)

        return pooled_image

    def backward(self, doutput):
        height, width = self.image.shape
        out = np.zeros(self.image.shape)

        for i in range(0, height, 2):
          for j in range(0, width, 2):
              block = self.image[i:i+2, j:j+2]
              max_val = np.max(block)

              for x in range(2):
                for y in range(2):
                  if block[x, y] == max_val:
                    out[i+x, j+y] = doutput[i//2, j//2]

        return out


pooling_layer = MaxPooling2D()
pooled_image = pooling_layer.forward(gray)
plt.imshow(pooled_image, cmap='gray')

back_pool = pooling_layer.backward(pooled_image)
plt.imshow(back_pool, cmap='gray')