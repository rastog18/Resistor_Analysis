# -*- coding: utf-8 -*-
"""Color_classification_proofofconcept.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cH4hdjISkekjATV1Bk6H_wMCNrZ4BuTj
"""

from google.colab import drive
drive.mount('/content/drive')

# Commented out IPython magic to ensure Python compatibility.
# %ls

# Commented out IPython magic to ensure Python compatibility.
# %cd drive/MyDrive/VIP_senior_design

import matplotlib.pyplot as plt
import numpy as np
from scipy import signal
import matplotlib.image as mimg
import cv2

# Specify the path to the image
IMG_PATH = '22ohm.JPEG'

# Load image using Mathplotlib
image = plt.imread(IMG_PATH)

plt.imshow(image)

def grayscale(img:np.array):
   #isolate the RGB channel of the image
    orgR = img[:, :, 0]
    orgG = img[:, :, 1]
    orgB = img[:, :, 2]

    #create greyscale image using BT.709 standard
    grayImage = 0.2126 * orgR + 0.7152 * orgG + 0.0722*orgB

    return grayImage

#image = mimg.imread(input_file)
grayScale = grayscale(image)
print("DONE WITH GRAYSCALE")

plt.imshow(grayScale, cmap='gray')

# Define gaussian window
gaussianWindow = (np.array([[1,2,1],[2,4,2],[1,2,1]]))/16

# Convolve grayscale image with gaussian window to smooth image
gaussian = signal.convolve2d(grayScale , gaussianWindow)

# Set dx and dy windows
dx = np.array([[-1,0,1],[-2,0,2],[-1,0,1]]).astype(np.float64)
dy = np.array([[-1,-2,-1],[0,0,0],[1,2,1]]).astype(np.float64)

# Convolve gaussian image with dx window
gx = signal.convolve2d(gaussian, dx)
plt.axis('off')
plt.imshow(gx, cmap='gray')

gy = signal.convolve2d(gaussian, dy)
plt.axis('off')
plt.imshow(gy, cmap='gray')

# Perform RSS (Root Sume Squared on gx and gy) to create sobel
sobel = np.sqrt(gx**2 + gy**2)
plt.axis('off')
plt.imshow(sobel, cmap='gray')

# Define color thresholds for resistor bands
color_threshold = {
    'black':   [(0, 0, 0), (40, 40, 40)],
    'brown':   [(40, 35, 30), (90, 65, 50)],
    'red':     [(150, 0, 0), (255, 70, 70)],
    'orange':  [(175, 100, 0), (255, 150, 50)],
    'yellow':  [(200, 200, 0), (255, 255, 50)],
    'green':   [(0, 150, 0), (50, 255, 50)],
    'blue':    [(0, 0, 150), (50, 50, 255)],
    'violet':  [(100, 0, 150), (220, 80, 220)],
    'grey':    [(100, 100, 100), (200, 200, 200)],
    'white':   [(230, 230, 230), (255, 255, 255)],
    'gold':    [(200, 150, 50), (255, 200, 100)],
    'silver':  [(180, 180, 180), (240, 240, 240)]
}


color_thresholds = {
    'black':   [(0, 0, 0), (40, 40, 40)],
    'brown':   [(40, 35, 30), (90, 65, 50)],
    'red':     [(120, 0, 0), (255, 70, 70)],
    'orange':  [(175, 100, 0), (255, 150, 50)],
    'yellow':  [(150, 150, 0), (255, 255, 100)],
    'green':   [(0, 150, 0), (50, 255, 50)],
    'violet':  [(80, 0, 100), (240, 120, 220)],
    'grey':    [(100, 100, 100), (200, 200, 200)],
    'white':   [(240, 240, 240), (255, 255, 255)],
    'gold':    [(200, 150, 50), (255, 200, 100)],
}

# Perform color thresholding for resistor bands
def color_threshold(image, color_ranges):
    result = np.zeros_like(image, dtype=np.uint8)
    for color, color_range in color_ranges.items():
        mask = np.all((image >= color_range[0]) & (image <= color_range[1]), axis=-1)
        result[mask] = color
    return result

"""DONT USE THE BELOW CODE, ITS NOT USEFUL"""

# Initialize an empty mask for each color
color_masks = {color: np.zeros_like(grayScale, dtype=np.uint8) for color in color_thresholds}

# Apply color thresholding for each color
for color, thresholds in color_thresholds.items():
    lower_threshold, upper_threshold = thresholds
    mask = np.all((image >= lower_threshold) & (image <= upper_threshold), axis=-1)
    color_masks[color] = mask

# Display the color masks
fig, axes = plt.subplots(3, 4, figsize=(12, 8))
axes = axes.flatten()

for i, (color, mask) in enumerate(color_masks.items()):
    axes[i].imshow(mask, cmap='gray')
    axes[i].set_title(color)
    axes[i].axis('off')

plt.show()

"""TRYING TO EXTRACT THE BANDS

"""

def extract_resistor_bands(image):
    # Convert the image to grayscale
    gray_image = cv2.cvtColor(image, cv2.COLOR_RGB2GRAY)

    # Apply Sobel edge detection
    sobelx = cv2.Sobel(gray_image, cv2.CV_64F, 1, 0, ksize=5)
    sobely = cv2.Sobel(gray_image, cv2.CV_64F, 0, 1, ksize=5)
    sobel_magnitude = np.sqrt(sobelx**2 + sobely**2)

    # Threshold the Sobel magnitude to create a binary image
    _, binary_image = cv2.threshold(sobel_magnitude, 50, 255, cv2.THRESH_BINARY)

    # Find contours in the binary image
    contours, _ = cv2.findContours(binary_image.astype(np.uint8), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    # Filter contours based on area (adjust the area threshold as needed)
    min_contour_area = 500
    resistor_bands = [contour for contour in contours if cv2.contourArea(contour) > min_contour_area]

    # Draw the contours on the original image
    result_image = image.copy()
    cv2.drawContours(result_image, resistor_bands, -1, (0, 255, 0), 2)

    return result_image

# Extract and visualize resistor bands
result_image = extract_resistor_bands(image)

plt.subplot(1, 2, 1)
plt.imshow(image)
plt.title('Original Image')

plt.subplot(1, 2, 2)
plt.imshow(result_image)
plt.title('Resistor Bands')

plt.show()

def detect_colors(original_image, thresholds):
    detected_colors = []

    for color, (lower, upper) in thresholds.items():
        mask = cv2.inRange(original_image, np.array(lower), np.array(upper))
        result = cv2.bitwise_and(original_image, original_image, mask=mask)

        # Check if any non-zero pixels are present in the result
        if np.any(result):
            detected_colors.append(color)
            print(f"Detected color: {color}")

    return detected_colors

# Detect colors in the original image
image = plt.imread(IMG_PATH)
detected_colors = detect_colors(image, color_thresholds)
print("Detected Colors:", detected_colors)

plt.show()

def detect_colors_print(original_image, thresholds):
    detected_colors = {}

    for color, (lower, upper) in thresholds.items():
        mask = cv2.inRange(original_image, np.array(lower), np.array(upper))
        result = cv2.bitwise_and(original_image, original_image, mask=mask)

        # Count non-zero pixels in the result
        pixel_count = np.count_nonzero(result)

        # Print color and pixel count information
        print(f"Color: {color}, Pixel Count: {pixel_count}")

        # Check if any non-zero pixels are present in the result
        if pixel_count > 0:
            detected_colors[color] = pixel_count

    return detected_colors

# Example usage:
image = plt.imread(IMG_PATH)
color_pixel_counts = detect_colors_print(image, color_thresholds)
print("Detected Colors and Pixel Counts:", color_pixel_counts)

import cv2
import numpy as np

# Load the image
image = cv2.imread('47ohms.JPEG')

# Convert to grayscale
gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

# Thresholding
_, thresh = cv2.threshold(gray, 100, 255, cv2.THRESH_BINARY)

# Noise reduction
kernel = np.ones((5, 5), np.uint8)
thresh = cv2.morphologyEx(thresh, cv2.MORPH_CLOSE, kernel)

# Edge detection
edges = cv2.Canny(thresh, 50, 150)

# Contour detection
contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

# Filter contours based on area or other criteria
# For simplicity, this example assumes the largest contour represents the resistor bands
largest_contour = max(contours, key=cv2.contourArea)

# Create bounding box around the resistor bands
x, y, w, h = cv2.boundingRect(largest_contour)

# Crop the image based on the bounding box
resistor_bands = image[y:y+h, x:x+w]

# Save or further process the cropped image
cv2.imwrite('resistor_bands.jpg', resistor_bands)