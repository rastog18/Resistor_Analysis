# -*- coding: utf-8 -*-
"""RGB_to_HSV.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10mphjIqkrJ50zQezct0let_RLzjIVwjY
"""

## RGB -> HSV
# Updated 2/10/2024 - Joseph Huang
# Created 2/3/2024 - Chaueen Kim

from google.colab import drive
drive.mount('/content/drive')

# Commented out IPython magic to ensure Python compatibility.
# %ls

# Commented out IPython magic to ensure Python compatibility.
# %cd drive/MyDrive

# Commented out IPython magic to ensure Python compatibility.
# %cd VIP-SD(Spring2024)

import matplotlib.pyplot as plt
import numpy as np
from PIL import Image

# Specify the path to the image
IMG_PATH = 'IMG_1966.jpg'

# Load image using Mathplotlib
image = plt.imread(IMG_PATH)

# Resize image to have width 250px to speed up algorithm
with Image.open(IMG_PATH) as img:
  width, height = img.size
  aspect_ratio = width / height
  new_width = 250
  new_height = int(new_width / aspect_ratio)
  image = np.array(img.resize((new_width, new_height)))

plt.imshow(image)

row = len(image)
col = len(image[1])

# Create zero filled arrays for red, green, blue, and gray
red = np.zeros((row, col), np.dtype(np.uint8))
green = np.zeros((row, col), np.dtype(np.uint8))
blue = np.zeros((row, col), np.dtype(np.uint8))
gray = np.zeros((row, col), np.dtype(np.uint8))

# Load values into red, green, blue arrays
# 2/10/2024: Speed up loading values by removing for loop
red = image[:,:,0]
green = image[:,:,1]
blue = image[:,:,2]

# BT 709 Grayscale Equation
gray = (0.183 * red) + (0.614 * green) + (0.062 * blue)

plt.imshow(gray, cmap='gray')

from google.colab.patches import cv2_imshow
import matplotlib.colors as color
import colorsys

r = red / 255
g = green / 255
b = blue / 255

print(red[1][1])
print(green[1][1])
print(blue[1][1])

h = np.zeros((row, col))
s = np.zeros((row, col))
v = np.zeros((row, col))

num = 0

for i in range(row):
  for j in range(col):
    cmax = max(r[i][j],g[i][j],b[i][j])
    cmin = min(r[i][j],g[i][j],b[i][j])

    diff = cmax - cmin

    if diff == 0:
      h[i][j] = 0
    elif cmax == r[i][j]:
      h[i][j] = (60 * ((g[i][j] - b[i][j]) / diff) + 360) % 360
    elif cmax == g[i][j]:
      h[i][j] = (60 * ((b[i][j] - r[i][j]) / diff) + 120) % 360
    elif cmax == b[i][j]:
      h[i][j] = (60 * ((r[i][j] - g[i][j]) / diff) + 240) % 360

    if cmax == 0:
      s[i][j] = 0
    else:
      s[i][j] = (diff / cmax)
    v[i][j] = cmax
    h[i][j] /= 360

hsv_image = np.stack((h, s, v), axis=-1)
plt.hsv()
plt.imshow(hsv_image)